extern "C"
{
	#include <esp8266.h>
	#include "httpd.h"
	#include <string.h>
}
#include "wifi_connector.h"

static const char g_web_index[] = {
		0xEF,0xBB,0xBF,0x3C,0x68,0x74,0x6D,0x6C,0x3E,0x0A,
		0x3C,0x68,0x65,0x61,0x64,0x3E,0x3C,0x6D,0x65,0x74,
		0x61,0x20,0x6E,0x61,0x6D,0x65,0x3D,0x22,0x76,0x69,
		0x65,0x77,0x70,0x6F,0x72,0x74,0x22,0x20,0x63,0x6F,
		0x6E,0x74,0x65,0x6E,0x74,0x3D,0x22,0x77,0x69,0x64,
		0x74,0x68,0x3D,0x64,0x65,0x76,0x69,0x63,0x65,0x2D,
		0x77,0x69,0x64,0x74,0x68,0x2C,0x20,0x69,0x6E,0x69,
		0x74,0x69,0x61,0x6C,0x2D,0x73,0x63,0x61,0x6C,0x65,
		0x3D,0x31,0x22,0x3E,0x0A,0x3C,0x6C,0x69,0x6E,0x6B,
		0x20,0x72,0x65,0x6C,0x3D,0x22,0x69,0x63,0x6F,0x6E,
		0x22,0x20,0x68,0x72,0x65,0x66,0x3D,0x22,0x64,0x61,
		0x74,0x61,0x3A,0x22,0x3E,0x0A,0x3C,0x73,0x74,0x79,
		0x6C,0x65,0x3E,0x68,0x74,0x6D,0x6C,0x20,0x7B,0x20,
		0x74,0x65,0x78,0x74,0x2D,0x61,0x6C,0x69,0x67,0x6E,
		0x3A,0x20,0x63,0x65,0x6E,0x74,0x65,0x72,0x3B,0x7D,
		0x20,0x3C,0x2F,0x73,0x74,0x79,0x6C,0x65,0x3E,0x3C,
		0x2F,0x68,0x65,0x61,0x64,0x3E,0x0A,0x3C,0x62,0x6F,
		0x64,0x79,0x3E,0x3C,0x68,0x31,0x3E,0x45,0x53,0x50,
		0x38,0x32,0x36,0x36,0x20,0x57,0x65,0x62,0x20,0x53,
		0x65,0x72,0x76,0x65,0x72,0x3C,0x2F,0x68,0x31,0x3E,
		0x0A,0x3C,0x70,0x3E,0x47,0x50,0x49,0x4F,0x20,0x32,
		0x20,0x2D,0x20,0x53,0x74,0x61,0x74,0x65,0x20,0x25,
		0x73,0x3C,0x2F,0x70,0x3E,0x20,0x20,0x20,0x20,0x20,
		0x0A,0x3C,0x70,0x3E,0x3C,0x61,0x20,0x68,0x72,0x65,
		0x66,0x3D,0x22,0x6F,0x6E,0x42,0x75,0x74,0x74,0x6F,
		0x6E,0x22,0x3E,0x3C,0x62,0x75,0x74,0x74,0x6F,0x6E,
		0x20,0x63,0x6C,0x61,0x73,0x73,0x3D,0x22,0x62,0x75,
		0x74,0x74,0x6F,0x6E,0x22,0x3E,0x4F,0x4E,0x3C,0x2F,
		0x62,0x75,0x74,0x74,0x6F,0x6E,0x3E,0x3C,0x2F,0x61,
		0x3E,0x3C,0x2F,0x70,0x3E,0x0A,0x3C,0x70,0x3E,0x3C,
		0x61,0x20,0x68,0x72,0x65,0x66,0x3D,0x22,0x6F,0x66,
		0x66,0x42,0x75,0x74,0x74,0x6F,0x6E,0x22,0x3E,0x3C,
		0x62,0x75,0x74,0x74,0x6F,0x6E,0x20,0x63,0x6C,0x61,
		0x73,0x73,0x3D,0x22,0x62,0x75,0x74,0x74,0x6F,0x6E,
		0x22,0x3E,0x4F,0x46,0x46,0x3C,0x2F,0x62,0x75,0x74,
		0x74,0x6F,0x6E,0x3E,0x3C,0x2F,0x61,0x3E,0x3C,0x2F,
		0x70,0x3E,0x0A,0x3C,0x2F,0x62,0x6F,0x64,0x79,0x3E,
		0x3C,0x2F,0x68,0x74,0x6D,0x6C,0x3E,0x0A, '\0'};

static char * g_web_index_formated = NULL;
typedef struct {
    int arrayPos;
    char buff[128];
} LongPageSendState;

bool g_ledState = false;

int ICACHE_FLASH_ATTR cgiIndex(HttpdConnData *connData) {

	LongPageSendState *state= (LongPageSendState *)connData->cgiData;
    int len;
    //If the browser unexpectedly closes the connection, the CGI will be called
    //with connData->conn=NULL. We can use this to clean up any data. It's pretty relevant
    //here because otherwise we may leak memory when the browser aborts the connection.
    if (connData->conn==NULL) {
        //Connection aborted. Clean up.
        if (state!=NULL) os_free(state);
        if(g_web_index_formated) {
        	os_free(g_web_index_formated);
        	g_web_index_formated = NULL;
        }
        return HTTPD_CGI_DONE;
    }

    if (state==NULL) {
        //This is the first call to the CGI for this webbrowser request.
        //Allocate a state structure.
        state= (LongPageSendState *)os_malloc(sizeof(LongPageSendState));
        g_web_index_formated = (char *)os_malloc(sizeof(g_web_index)+10);
        //Save the ptr in connData so we get it passed the next time as well.
        connData->cgiData=state;
        //Set initial pointer to start of string
        state->arrayPos= 0;
        state->buff[0] = 0;
        //We need to send the headers before sending any data. Do that now.
        httpdStartResponse(connData, 200);
        httpdHeader(connData, "Content-Type", "text/html");
        httpdEndHeaders(connData);
    }

    //Figure out length of string to send. We will never send more than 128 bytes in this example.

    os_sprintf(g_web_index_formated, g_web_index,  g_ledState ? "ON" : "OFF");
    len = os_strlen(g_web_index_formated) - state->arrayPos; //Get remaining length
    if (len>128) len=128; //Never send more than 128 bytes
    if (len==0) {
    	os_free(state);
    	os_free(g_web_index_formated);
    	g_web_index_formated = NULL;
    	return HTTPD_CGI_DONE;
    }

    uint32_t fd = 0;
    for (int i=0; i < len; i+=4)
    {
    	fd = *((uint32_t*)&g_web_index_formated[state->arrayPos + i]);
    	state->buff[i] = (char) (fd & 0xFF);
    	state->buff[i+1] = (char) ((fd >> 8) & 0xFF);
    	state->buff[i+2] = (char) ((fd >> 16) & 0xFF);
    	state->buff[i+3] = (char) ((fd >> 24) & 0xFF);
    }

    //Send that amount of data
    httpdSend(connData, state->buff, len);
    //Adjust stringPos to first byte we haven't sent yet
    state->arrayPos+=len;
    //See if we need to send more
    if (len == 128) {
        //we have more to send; let the webserver call this function again.
        return HTTPD_CGI_MORE;
    } else {
        //We're done. Clean up here as well: if the CGI function returns HTTPD_CGI_DONE, it will
        //not be called again.
        os_free(state);
        os_free(g_web_index_formated);
        g_web_index_formated = NULL;
        return HTTPD_CGI_DONE;
    }
}

int ICACHE_FLASH_ATTR cgiOnButton(HttpdConnData *connData){
	g_ledState = true;
	ioLed(1);
	//os_sprintf(g_web_index_formated, g_web_index, "ON");
	return cgiRedirect(connData);
}
int ICACHE_FLASH_ATTR cgiOffButton(HttpdConnData *connData){
	g_ledState = false;
	ioLed(0);
	//os_sprintf(g_web_index_formated, g_web_index, "OFF");
	return cgiRedirect(connData);
}

HttpdBuiltInUrl builtInUrls[]={
	{"*", cgiRedirectApClientToHostname, "esp.nonet"},
	{"/", cgiRedirect, "/index.html"},
    {"/index.html", cgiIndex, NULL},
	{"/onButton", cgiOnButton, "/index.html"},
	{"/offButton", cgiOffButton, "/index.html"},
    {NULL, NULL, NULL}
};

void ICACHE_FLASH_ATTR WebInit() {

	//os_sprintf(g_web_index_formated, g_web_index, "OFF");
	httpdInit(builtInUrls, 80);
}

